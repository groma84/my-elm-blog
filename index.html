<!doctype html>
<html lang="de">

<head>
    <meta charset="utf-8">
    <meta name="description" content="Ein Blog zur funktionalen Frontend-Programmiersprache Elm">
    <meta name="keywords" content="elm, functional, programming, funktional, funktionale programmierung, spa, web, frontend">
    <link rel="stylesheet" href="main.css">
    <link rel="stylesheet" href="/highlightjs-styles/sunburst.css">
    <title>Elm - finde ich super!</title>
</head>

<body>
    <header>
        <h1>Elm - finde ich super!</h1>
        <nav>
            <ul>
                <li>
                    <a href="index.html">Blog</a>
                </li>
                <li>
                    <a href="faq.html">FAQ</a>
                </li>
                <li>
                    <a href="impressum.html">Impressum</a>
                </li>
            </ul>
        </nav>
    </header>
    <section id="main-content">
        <article>
            <h2>
                Coole Typen - Teil 3
            </h2>
            <h3>von Martin Grotz, 2018-05-23</h3>
            <p>Jetzt geht es zu den Union Types. Diese haben sehr viele verschiedene Namen, je nach Programmiersprache oder
                Community in der man sich bewegt: Union Types, Discriminated Unions, Tagged Unions, Algebraic Datatypes oder
                auch Choice Types. Choice Types drückt für mich auch am ehesten aus, was man damit machen kann, ohne, dass
                man das ganze Hintergrundwissen dazu braucht:
                <br> Man kann damit eine feststehende, zur Kompilierzeit bereits bekannte Menge an verschiedenen Auswahlmöglichkeiten
                beschreiben. Union Types sind das wohl wichtigste Werkzeug, um eine Fachdomäne sauber und inklusive der Vermeidung
                von ungültigen Zuständen auszudrücken.
            </p>
            <p>Zuerst einmal schauen wir uns Union Types ohne zusätzliche Daten pro Auswahl an:</p>
            <pre><code>type Hintergrundfarbe = Rot | Gelb | Blau</code></pre>
            <p>Wenn wir nun in unserer Webseite je nach Hintergrundfarbe einen passenden CSS-Hexcode ausspucken wollen, können
                wir eine Funktion schreiben, die mit einem
                <code class="inline">case ... of</code> die verschiedenen Fälle auswertet. Das nennt man dann Pattern Matching:</p>
            <pre><code>farbeZuHex : Hintergrundfarbe -> String
farbeZuHex hintergrundfarbe =
    case hintergrundfarbe of
        Rot ->
            "#ff0000"
        Gelb ->
            "#ffff00"              
        Blau ->
            "#0000ff"</code></pre>
            <p>Wichtig ist dabei auch: Elm erzwingt immer die Behandlung aller Pfade. Man kann zwar mit
                <code class="inline">_ -> ...</code> einen Standardfall festlegen, der immer dann ausgeführt wird, wenn kein anderer Zweig passt, aber dann hebelt
                man einen wichtigen Schutzmechanismus gegen Programmierfehler aus, daher ist nicht unbedingt empfehlenswert.</p>
            <p>Eine weitere wichtige Einsatzmöglichkeit von Union Types sind die sogenannten Single Case Union Types. Diese
                dienen vor allem dazu, Funktionsparameter eindeutig festzulegen, so dass man nicht aus Versehen zum Beispiel
                zwei Floats beim Aufruf verdreht. Dies zu nutzen erhöht die Lesbarkeit und Sicherheit des eigenen Codes deutlich!</p>
            <pre><code>type Gewicht = Gewicht Float
type Groesse = Groesse Float
type alias Bmi = Float

errechneBmi : Gewicht -> Groesse -> Bmi
errechneBmi (Gewicht gewicht) (Groesse groesse) =
    gewicht / (groesse * groesse)</code></pre>
            <p>Im Gegensatz zu dem type alias Bmi, der letztendlich nur eine Umbenennung eines Floats darstellt, und damit auch
                überall dort als Argument erlaubt ist, wo ein Float erwartet wird, sorgen die beiden Single Case Unions dafür,
                dass die Reihenfolge wirklich eingehalten werden muss. Wäre die Funktionssignatur ein
                <code class="inline">Float -> Float -> Float</code> bestündie die sehr große Gefahr, dass man Gewicht und Größe beim Aufruf vertauscht und dabei sinnlose Ergebnisse
                erhält, obwohl der Compiler grünes Licht gibt.</p>
            <p>In der berechneBmi-Funktion sieht man auch, wie man einen solchen Union Type auch gleich elegant "auspacken"
                kann, so dass man direkt mit den "enthaltenen" Floats arbeiten kann.</p>
            <p>Auch viele interne Typen von Elm sind eigentlich Union Types, zum Beispiel Boolean oder das später noch genauer
                erläuterte Maybe bzw. Result.</p>
            <p>Eine weitere wichtige Möglichkeit für den Einsatz von Union Types ist es, jedem einzelnen Fall unterschiedliche
                Daten mitgeben zu können. Das macht sie wesentlich mächtiger als die aus vielen anderen Sprachen bekannten
                switch-case-Statements:
            </p>
            <pre><code>type alias Radius = Float
type alias Laenge = Float
type alias Breite = Float

type Form
    = Kreis Radius
    | Rechteck Laenge Breite

flaeche : Form -> Float
flaeche form =
    case form of
        Kreis radius ->
            pi * (radius ^ 2)

        Rechteck laenge breite ->
            laenge * breite</code></pre>
            <p>Durch die geschickte Kombination von Union Types kann man innerhalb seiner Fachdomäne eine auch für Domänenexperten,
                die sich mit Programmierung nicht so gut auskennen, gut verständliche Beschreibung erstellen, die dann auch
                noch beim Programmieren wenig fehleranfällig ist. Deshalb bilden Union Types meist das Rückgrat jeder Elm-Typbeschreibung.</p>
            <p>Die ausführlichere offizielle Doku zum Thema findet sich
                <a href="https://guide.elm-lang.org/types/union_types.html">auf der Elm-Seite</a>.</p>
        </article>

        <article>
            <h2>
                Coole Typen - Teil 2
            </h2>
            <h3>von Martin Grotz, 2018-05-13</h3>
            <p>
                Wie angekündigt geht es in diesem Teil der Elm-Typen-Betrachung um Listen und Union Types. Beginnen wollen wir hierbei mit
                den Listen. Listen sind in Elm das Standardmittel um Mengen von Elementen zu verwalten. Listen sind, genau
                wie alle anderen Datentypen in Elm, unveränderlich ("immutable"), d.h. fügt man ein Element hinzu oder entfernt
                eines, so bekommt man immer eine Kopie der Liste zurück - das Original bleibt unverändert bestehen.
            </p>
            <p>
                Listen werden einfach mit eckigen Klammern definiert. Mehrere Elemente trennt man mit einem Komma:
            </p>
            <pre><code>liste =
[ 1, 2, 3, 5, 7, 11 ]</code></pre>
            <p>Es gibt auch einige andere Möglichkeiten, Listen zu erzeugen. Hierzu verweise ich auf die
                <a href="http://package.elm-lang.org/packages/elm-lang/core/latest/List">Elm-Dokumentation zur Liste</a>.</p>
            <p>Es gibt auch noch eine Menge weiterer Funktionen, die auf Listen operieren. Besonders hervorheben möchte ich
                hier die Möglichkeit, via
                <code class="inline">head</code> auf das erste Element einer Liste zugreifen zu können - das machen wir uns in einem späteren Eintrag beim
                Einführen des Pattern Matching zu nutze, und
                <code class="inline">map</code>. </p>
            <p>Mit
                <code class="inline">map</code> kann man über alle Elemente einer Liste iterieren und auf jedes Element eine Funktion anwenden. Das Ergebnis
                dieser Funktion wird dann an die gleiche Stelle einer neuen Liste geschrieben. Dies bildet eine mächtige
                Möglichkeit, alle Elemente einer Liste zu transformieren.</p>
            <pre><code>-- Listen
liste : List Int
liste =
    [ 1, 2, 3, 5, 7, 11 ]

quadriere : Int -> Int
quadriere a =
    a ^ a

quadrierteListe : List Int
quadrierteListe =
    List.map quadriere liste</code></pre>
            <p>Listen sind auch deshalb ein sehr wichtiger Bestandteil von Elm weil in allen view-Funktionen die HTML-Elemente
                jeweils Funktionen sind, die einerseits eine Liste von Attributen, andererseits eine Liste mit Kindelementen
                entgegennehmen. Daher kann man sich mit Hilfe der zahlreichen Listen-Funktionen sehr elegant seine HTML-Views
                bauen.
            </p>
            <p>Für die Union Types gibt's dann doch noch einen eigenen Artikel, da diese vermutlich etwas mehr Raum und Zeit
                in Anspruch nehmen werden.</p>
        </article>

        <article>
            <h2>
                Coole Typen - Teil 1
            </h2>
            <h3>von Martin Grotz, 2018-05-02</h3>
            <p>
                Bevor wir mit dem Umsetzen der Fachdomäne in Elm-Typen anfangen können müssen wir natürlich wissen, welche Typen es in Elm
                überhaupt gibt und was wir damit jeweils machen können. Im ersten Teil der dreiteiligen Artikel-Reihe geht
                es um die grundlegenden Typen:
                <section>
                    <h4>
                        Primitive Typen
                    </h4>
                    Es gibt in Elm eine Reihe von grundlegenden Typen, die dann zu anderen Typen zusammengesetzt werden. Im Detail sind das:
                    <ul>
                        <li>Char: Einzelnes Zeichen</li>
                        <li>String: Zeichenketten</li>

                        <li>Bool: True oder False, um einen Wert darzustellen, der entweder Wahr oder Unwahr sein kann</li>
                        <li>Int: Ganze Zahl</li>
                        <li>Float: Kommazahl</li>
                        <li>number: Kann entweder Int oder Float sein - je nach tatsächlicher Verwendung</li>
                    </ul>

                    Als Elm-Code sieht das dann jeweils so aus:
                    <pre><code>c : Char
c =
    'a'

s : String
s =
    "Zeichenkette"

b : Bool
b =
    True

i : Int
i =
    42

f : Float
f =
    3.1415

n1 : number
n1 =
    42

n2 : number
n2 =
    3.1415</code></pre>
                </section>

                <section>
                    <h4>Records</h4>
                    <p>Records sind unveränderliche Datenstrukturen, die aus mehreren Werten zusammengesetzt sind. Sie werden
                        in Elm für gewöhnlich als Type-Alias definiert - theoretisch kann man aber auch direkt einen Record
                        an Ort und Stelle definieren, ohne vorher einen passenden Type-Alias angelegt zu haben.
                    </p>
                    <p>Wichtig: Records in Elm werden über ihren Inhalt verglichen - nicht über ihre Referenz. Außerdem: Records
                        in Elm erfüllen dann eine Funktions-Signatur, wenn sie strukturell passen.</p>
                    <p>In Elm-Code sieht das dann so aus:</p>
                    <pre><code>-- Record
somePoint =
    { x = 3, y = -1 }

-- Record mit dazugeschriebener Typdefinition
aPoint : { x : Int, y : Int }
aPoint =
    { x = 3, y = -1 }

-- Record Type für einfachere wiederholte Verwendung
type alias Point =
    { x : Int, y : Int }

anotherPoint : Point
anotherPoint =
    { x = 3, y = -1 }

-- beide Records erfüllen die Funktions-Signatur von someFunc, weil die Struktur jeweils passt
someFunc : Point -> Point -> Point
someFunc p1 p2 =
    { x = p1.x + p2.x, y = p1.y + p2.y }

x =
    someFunc somePoint anotherPoint</code></pre>

                    <p>Noch mehr Infos zu Records gibt es
                        <a href="http://elm-lang.org/docs/records">in der offiziellen Elm-Doku</a>.</p>
                </section>
            </p>

            <p>Im nächsten Teil der Serie geht es dann um Union Types und Listen.</p>
        </article>

        <article>
            <h2>
                A Cure for Runtime Errors - Vortrag vom MATHEMA Campus 2018
            </h2>
            <h3>von Martin Grotz, 2018-04-22</h3>
            <p>
                Ich hatte kürzlich die Gelegenheit, auf dem internen
                <a href="https://www.mathema.de/veranstaltungen/mathema-campus">MATHEMA Campus</a> vor einer Handvoll Zuhörer aus dem "Family&Friends"-Bereich meines Arbeitgebers einen
                kurzen Vortrag über Elm zu halten. Schwerpunkt war hierbei, wie Elm dabei hilft, Laufzeitfehler in Web-Frontends
                zu verhindern. Daher hieß der Vortrag dann auch
                <em>"A Cure for Runtime Errors</em>. Ich habe die Folien zum Vortrag
                <a href="https://elm.finde-ich-super.de/vortrag-mathemacampus-2018">als HTML-Seite hochgeladen</a>.
            </p>
            <p>Die Code-Beispiele finden sich
                <a href="https://github.com/groma84/a-cure-for-runtime-errors-elm-vortrag">auf meinem Github-Account</a>.</p>
        </article>
        <article>
            <h2>
                Das erste Projekt: Ein Kartenspiel
            </h2>
            <h3>von Martin Grotz, 2018-04-18</h3>
            <p>Am einfachsten lernt man mit einer neuen Programmiersprache meiner Meinung nach umzugehen, indem man ein konkretes
                kleines Projekt in Angriff nimmt.</p>
            <p>Viele der Herausforderungen zeigen sich nämlich erst, wenn man zumindest ein klein wenig über Hello World hinausgeht.</p>
            <p>Da es aber auch nicht zu kompliziert werden soll, habe ich mich für eine Einzelspieler-Browser-only-Variante
                eines Kartenspiels entschieden:
                <br> Die Regeln des Spiels "Schnarch Schnarch" sind überschaubar und auch im
                <a href="http://www.spielanleitung.com/spiel.php4?id=1899">Internet verfügbar</a>.
            </p>
            <p>Im Laufe der Entwicklung werde ich auch immer wieder mal Artikel einschieben, die jeweils Funktionalität oder
                Syntax von Elm erklären, die ich danach dann gebrauchen werde. So wird es nicht zu viel trockene Theorie,
                aber sie fällt auch nicht ganz untern den Tisch!</p>

            <p>Jetzt ist aber erstmal nur das Anlegen des Projektskeletts dran. Hierzu verwenden wir erneut die praktischen
                Befehle, die uns
                <a href="https://github.com/halfzebra/create-elm-app">create-elm-app</a> zur Verfügung stellt:
                <code>elm-app create schnarchschnarch-sp-elm</code>
            </p>

            <p>Anschließend wird erstmal aufgeräumt: Im
                <code class="inline">public</code>-Ordner, der die statischen Ressourcen enthält, werfen wir alles außer
                <code class="inline">index.html</code> weg.</p>

            <p>Nun folgt noch der
                <code class="inline">source</code>-Ordner, der den eigentlichen Elm-Quellcode enthält. Hier entfernen wir in der
                <code class="inline">index.js</code>-Datei erstmal die Verbindung zum ServiceWorker durch das Löschen der Zeilen
                <code>import registerServiceWorker from './registerServiceWorker';</code> und
                <code>registerServiceWorker();</code> Die zugehörige Datei
                <code class="inline">registerServiceWorker.js</code> wird gelöscht.
            </p>

            <p>
                In
                <code class="inline">Main.elm</code> - dem Einsprungpunkt jedes Elm-Programms - vereinfachen wir die
                <code class="inline">view</code>-Funktion derart, dass sie folgendermaßen aussieht:
                <pre><code>view : Model -> Html Msg
view model =
    div [] []</code></pre> Dadurch wird nurmehr eine Seite mit einem leeren
                <code class="inline">div</code> erzeugt.
            </p>

            <p>Damit ist die Leinwand vorbereitet, um jetzt mit dem nächsten Schritt weitermachen zu können: Die Fachdomäne
                analysieren und daraus möglichst gute Typdefinitionen zu erstellen.</p>
        </article>

        <article>
            <h2>Elm-Schnellstart</h2>
            <h3>von Martin Grotz, 2018-04-17</h3>
            <p>Die Installation von Elm ist sehr einfach. Die einzige Voraussetzung ist ein aktuelles
                <a href=" https://nodejs.org ">node.js</a>.</p>
            <p>Anschließend kann man alle wichtigen Tools und die Programmiersprache selbst mit einem einzigen Befehl herunterladen:
                <code>npm install elm elm-format create-elm-app --global</code> Danach können wir uns schon eine erste App erzeugen und in den neu erzeugten Ordner wechseln:
                <code>elm-app create hello-world
                    <br>
                    cd hello-world
                </code> Dort starten wir den Entwicklungswebserver via
                <code>elm-app start</code> Damit sind wir auch schon fertig und können uns den Output unseres Elm-Programms im Browser anschauen. Dazu
                rufen wir die Standard-URL des Entwicklungswebservers auf:
                <code>http://localhost:3000/</code>
            </p>
        </article>

        <!-- <article>
            <h2>

            </h2>
            <h3></h3>
            <p></p>
        </article> -->
    </section>

    <script src="./highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</body>

</html>